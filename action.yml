name: TF GitHub Action
description: This action will validate, plan and apply your OpenTofu configuration.

branding:
  icon: 'arrow-up'
  color: 'yellow'

inputs:
  version:
    description: "The OpenTofu version to install (e.g., 1.11.x)."
    required: false
    default: "1.11.x"
  workdir:
    description: "Path to the TF configuration directory (relative to repository root)."
    required: false
    default: "."
  env:
    description: "Deployment environment (eg `dev`, `staging` or `prod`). Accepts any string."
    required: false
    default: ""
  steps:
    description: 'Steps to run: `validate`, `plan`, `apply`, `test` (comma, space or newline separated). Use `all`` to run all steps.'
    required: false
    default: 'all'
  tfvar-files:
    description: 'Comma, space or newline separated list of tfvar files to include'
    required: false
    default: ''
  tfvars:
    description: 'Comma, space or newline separated key-value pairs for terraform variables (format: key1=value1)'
    required: false
    default: ''
  backend-config-var-files:
    description: 'Comma, space or newline  separated list of backend config files to include'
    required: false
    default: ''
  backend-config-vars:
    description: 'Comma, space or newline separated key-value pairs for backend configuration (format: key1=value1)'
    required: false
    default: ''
  test-dir:
    description: 'Directory containing OpenTofu tests (relative to workdir)'
    required: false
    default: 'tests'
  test-tfvar-files:
    description: 'Comma, space or newline separated list of tfvar files to include for tests (defaults to tfvar-files)'
    required: false
    default: ''
  test-tfvars:
    description: 'Comma, space or newline separated key-value pairs for test variables (defaults to tfvars)'
    required: false
    default: ''
  lock-timeout:
    description: 'State lock timeout for plan/apply (e.g., 5m)'
    required: false
    default: ''
  parallelism:
    description: 'Parallelism for plan/apply'
    required: false
    default: ''
  refresh:
    description: 'Refresh behavior for plan/apply (`true` or `false`)'
    required: false
    default: ''
  targets:
    description: 'Comma, space or newline separated list of target resources for plan/apply'
    required: false
    default: ''
  artifact-retention-days:
    description: 'Retention days for plan artifacts (1-90). Leave empty to use repository default'
    required: false
    default: ''
  skip-plan-upload:
    description: 'Skip uploading the plan artifact'
    required: false
    default: 'false'
  summary-mode:
    description: 'Plan/apply summary mode: `full`, `redacted`, or `off`'
    required: false
    default: 'full'
  comment-mode:
    description: 'PR comment mode: `sticky` to update a single comment or `off` to disable comments'
    required: false
    default: 'sticky'
  comment-identifier:
    description: 'Identifier used to find/update sticky PR comments'
    required: false
    default: 'tf-github-action'


runs:
  using: "composite"
  steps:
    - name: Setup OpenTofu
      uses: opentofu/setup-opentofu@v1
      with:
        tofu_version: ${{ inputs.version }}
        tofu_wrapper: false

    - name: Parse steps
      id: parse-steps
      shell: bash
      run: |
        STEPS_INPUT="${{ inputs.steps }}"
        if [ -z "$STEPS_INPUT" ]; then
          STEPS_INPUT="all"
        fi

        NORMALISED=$(echo "$STEPS_INPUT" | tr '\n,' ' ' | tr -s ' ' | xargs)

        RUN_VALIDATE=false
        RUN_PLAN=false
        RUN_APPLY=false
        RUN_TEST=false

        if [ -z "$NORMALISED" ] || [ "$NORMALISED" = "all" ] || [[ " $NORMALISED " == *" all "* ]]; then
          RUN_VALIDATE=true
          RUN_PLAN=true
          RUN_APPLY=true
          RUN_TEST=true
        else
          PADDED=" $NORMALISED "
          if [[ "$PADDED" == *" validate "* ]]; then
            RUN_VALIDATE=true
          fi
          if [[ "$PADDED" == *" plan "* ]]; then
            RUN_PLAN=true
          fi
          if [[ "$PADDED" == *" apply "* ]]; then
            RUN_APPLY=true
          fi
          if [[ "$PADDED" == *" test "* ]]; then
            RUN_TEST=true
          fi
        fi

        echo "run_validate=$RUN_VALIDATE" >> $GITHUB_OUTPUT
        echo "run_plan=$RUN_PLAN" >> $GITHUB_OUTPUT
        echo "run_apply=$RUN_APPLY" >> $GITHUB_OUTPUT
        echo "run_test=$RUN_TEST" >> $GITHUB_OUTPUT

    - name: Parse CLI args
      id: parse-cli-args
      shell: bash
      run: |
        LOCK_TIMEOUT="${{ inputs['lock-timeout'] }}"
        PARALLELISM="${{ inputs.parallelism }}"
        REFRESH="${{ inputs.refresh }}"
        TARGETS="${{ inputs.targets }}"
        COMMON_ARGS=""
        PLAN_ARGS=""
        APPLY_ARGS=""

        if [ -n "$LOCK_TIMEOUT" ]; then
          COMMON_ARGS="$COMMON_ARGS -lock-timeout=$LOCK_TIMEOUT"
        fi

        if [ -n "$PARALLELISM" ]; then
          COMMON_ARGS="$COMMON_ARGS -parallelism=$PARALLELISM"
        fi

        if [ -n "$REFRESH" ]; then
          case "$REFRESH" in
            true|false)
              PLAN_ARGS="$PLAN_ARGS -refresh=$REFRESH"
              ;;
            *)
              echo "Error: refresh must be 'true' or 'false'"
              exit 1
              ;;
          esac
        fi

        if [ -n "$TARGETS" ]; then
          NORMALISED_TARGETS=$(echo "$TARGETS" | tr '\n,' ' ' | tr -s ' ')
          for target in $NORMALISED_TARGETS; do
            target=$(echo "$target" | xargs)
            if [ -n "$target" ]; then
              PLAN_ARGS="$PLAN_ARGS -target=$target"
            fi
          done
        fi

        COMMON_ARGS=$(echo "$COMMON_ARGS" | sed 's/^ *//')
        PLAN_ARGS=$(echo "$PLAN_ARGS" | sed 's/^ *//')

        if [ -n "$COMMON_ARGS" ]; then
          APPLY_ARGS="$COMMON_ARGS"
          if [ -n "$PLAN_ARGS" ]; then
            PLAN_ARGS="$COMMON_ARGS $PLAN_ARGS"
          else
            PLAN_ARGS="$COMMON_ARGS"
          fi
        fi

        PLAN_ARGS=$(echo "$PLAN_ARGS" | sed 's/^ *//')
        APPLY_ARGS=$(echo "$APPLY_ARGS" | sed 's/^ *//')

        echo "plan_args=$PLAN_ARGS" >> $GITHUB_OUTPUT
        echo "apply_args=$APPLY_ARGS" >> $GITHUB_OUTPUT

    - name: Parse artifact retention
      id: parse-retention
      shell: bash
      run: |
        RETENTION_DAYS="${{ inputs['artifact-retention-days'] }}"
        if [ -n "$RETENTION_DAYS" ]; then
          if ! [[ "$RETENTION_DAYS" =~ ^[0-9]+$ ]]; then
            echo "Error: artifact-retention-days must be a number"
            exit 1
          fi
          if [ "$RETENTION_DAYS" -lt 1 ] || [ "$RETENTION_DAYS" -gt 90 ]; then
            echo "Error: artifact-retention-days must be between 1 and 90"
            exit 1
          fi
          echo "retention_days=$RETENTION_DAYS" >> $GITHUB_OUTPUT
        fi

    - name: Parse backend config files
      id: parse-backend-config-files
      shell: bash
      working-directory: ${{ inputs.workdir }}
      run: |
        BACKEND_CONFIG_FILES="${{ inputs['backend-config-var-files'] }}"
        BACKEND_CONFIG_ARGS=""

        if [ -n "$BACKEND_CONFIG_FILES" ]; then
          NORMALISED_FILES=$(echo "$BACKEND_CONFIG_FILES" | tr '\n,' ' ' | tr -s ' ')

          # Convert to array and build -backend-config arguments
          for file in $NORMALISED_FILES; do
            # Trim whitespace
            file=$(echo "$file" | xargs)
            if [ -n "$file" ]; then
              # Verify file exists
              if [ -f "$file" ]; then
                BACKEND_CONFIG_ARGS="$BACKEND_CONFIG_ARGS -backend-config=$file"
                echo "Added backend config file: $file"
              else
                echo "Warning: backend config file not found: $file"
                exit 1
              fi
            fi
          done

          # Remove leading space
          BACKEND_CONFIG_ARGS=$(echo "$BACKEND_CONFIG_ARGS" | sed 's/^ *//')
        fi

        echo "backend-config-file-args=$BACKEND_CONFIG_ARGS" >> $GITHUB_OUTPUT
        echo "Backend config file arguments: $BACKEND_CONFIG_ARGS"

    - name: Parse backend config vars
      id: parse-backend-config-vars
      shell: bash
      run: |
        BACKEND_CONFIG_VARS="${{ inputs['backend-config-vars'] }}"
        BACKEND_CONFIG_ARGS=""

        if [ -n "$BACKEND_CONFIG_VARS" ]; then
          # Handle spaces, newlines, and commas as separators
          # First normalize all separators to spaces, then split on spaces
          NORMALISED_VARS=$(echo "$BACKEND_CONFIG_VARS" | tr '\n,' ' ' | tr -s ' ')

          # Split by spaces and process each key=value pair
          read -ra PAIRS <<< "$NORMALISED_VARS"
          for pair in "${PAIRS[@]}"; do
            pair=$(echo "$pair" | xargs)
            if [ -n "$pair" ]; then
              # Validate key=value format (backend config keys can be more flexible)
              if [[ "$pair" =~ ^[a-zA-Z_][a-zA-Z0-9_.-]*=.* ]]; then
                BACKEND_CONFIG_ARGS="$BACKEND_CONFIG_ARGS -backend-config=$pair"
                echo "Added backend config: ${pair%%=*}"
              else
                echo "Error: Invalid backend config format: $pair"
                echo "Expected format: key=value"
                exit 1
              fi
            fi
          done

          # Remove leading space
          BACKEND_CONFIG_ARGS=$(echo "$BACKEND_CONFIG_ARGS" | sed 's/^ *//')
        fi

        echo "backend-config-args=$BACKEND_CONFIG_ARGS" >> $GITHUB_OUTPUT
        echo "Backend config arguments: $BACKEND_CONFIG_ARGS"

    - name: Init
      shell: bash
      working-directory: ${{ inputs.workdir }}
      run: |
        tofu init ${{ steps.parse-backend-config-files.outputs.backend-config-file-args }} \
        ${{ steps.parse-backend-config-vars.outputs.backend-config-args }}

    - name: Parse tfvar files
      id: parse-tfvar-files
      shell: bash
      working-directory: ${{ inputs.workdir }}
      run: |
        TFVAR_FILES="${{ inputs['tfvar-files'] }}"
        TFVAR_ARGS=""

        if [ -n "$TFVAR_FILES" ]; then
          # Handle spaces, newlines, and commas as separators
          NORMALISED_FILES=$(echo "$TFVAR_FILES" | tr '\n,' ' ' | tr -s ' ')

          # Convert to array and build -var-file arguments
          for file in $NORMALISED_FILES; do
            # Trim whitespace
            file=$(echo "$file" | xargs)
            if [ -n "$file" ]; then
              # Verify file exists
              if [ -f "$file" ]; then
                TFVAR_ARGS="$TFVAR_ARGS -var-file=$file"
                echo "Added tfvar file: $file"
              else
                echo "Warning: tfvar file not found: $file"
                exit 1
              fi
            fi
          done

          # Remove leading space
          TFVAR_ARGS=$(echo "$TFVAR_ARGS" | sed 's/^ *//')
        fi

        echo "tfvar-file-args=$TFVAR_ARGS" >> $GITHUB_OUTPUT
        echo "Tfvar file arguments: $TFVAR_ARGS"

    - name: Parse tfvars
      id: parse-tfvars
      shell: bash
      run: |
        TFVARS="${{ inputs.tfvars }}"
        TFVAR_ARGS=""

        if [ -n "$TFVARS" ]; then
          # Handle spaces, newlines, and commas as separators
          NORMALISED_VARS=$(echo "$TFVARS" | tr '\n,' ' ' | tr -s ' ')

          # Split by spaces and process each key=value pair
          read -ra PAIRS <<< "$NORMALISED_VARS"
          for pair in "${PAIRS[@]}"; do
            pair=$(echo "$pair" | xargs)
            if [ -n "$pair" ]; then
              # Validate key=value format
              if [[ "$pair" =~ ^[a-zA-Z_][a-zA-Z0-9_]*=.* ]]; then
                TFVAR_ARGS="$TFVAR_ARGS -var=$pair"
                echo "Added tfvar: ${pair%%=*}"
              else
                echo "Error: Invalid tfvar format: $pair"
                echo "Expected format: key=value"
                exit 1
              fi
            fi
          done

          # Remove leading space
          TFVAR_ARGS=$(echo "$TFVAR_ARGS" | sed 's/^ *//')
        fi

        echo "tfvar-args=$TFVAR_ARGS" >> $GITHUB_OUTPUT

    - name: Resolve test variables
      id: resolve-test-vars
      if: ${{ steps.parse-steps.outputs.run_test == 'true' }}
      shell: bash
      run: |
        TEST_TFVAR_FILES="${{ inputs['test-tfvar-files'] }}"
        if [ -z "$TEST_TFVAR_FILES" ]; then
          TEST_TFVAR_FILES="${{ inputs['tfvar-files'] }}"
        fi

        TEST_TFVARS="${{ inputs['test-tfvars'] }}"
        if [ -z "$TEST_TFVARS" ]; then
          TEST_TFVARS="${{ inputs['tfvars'] }}"
        fi

        echo "test_tfvar_files=$TEST_TFVAR_FILES" >> $GITHUB_OUTPUT
        echo "test_tfvars=$TEST_TFVARS" >> $GITHUB_OUTPUT

    - name: Parse test tfvar files
      id: parse-test-tfvar-files
      if: ${{ steps.parse-steps.outputs.run_test == 'true' }}
      shell: bash
      working-directory: ${{ inputs.workdir }}
      run: |
        TEST_TFVAR_FILES="${{ steps.resolve-test-vars.outputs.test_tfvar_files }}"
        TEST_TFVAR_ARGS=""

        if [ -n "$TEST_TFVAR_FILES" ]; then
          NORMALISED_FILES=$(echo "$TEST_TFVAR_FILES" | tr '\n,' ' ' | tr -s ' ')

          for file in $NORMALISED_FILES; do
            file=$(echo "$file" | xargs)
            if [ -n "$file" ]; then
              if [ -f "$file" ]; then
                TEST_TFVAR_ARGS="$TEST_TFVAR_ARGS -var-file=$file"
                echo "Added test tfvar file: $file"
              else
                echo "Warning: test tfvar file not found: $file"
                exit 1
              fi
            fi
          done

          TEST_TFVAR_ARGS=$(echo "$TEST_TFVAR_ARGS" | sed 's/^ *//')
        fi

        echo "test-tfvar-file-args=$TEST_TFVAR_ARGS" >> $GITHUB_OUTPUT

    - name: Parse test tfvars
      id: parse-test-tfvars
      if: ${{ steps.parse-steps.outputs.run_test == 'true' }}
      shell: bash
      run: |
        TEST_TFVARS="${{ steps.resolve-test-vars.outputs.test_tfvars }}"
        TEST_TFVAR_ARGS=""

        if [ -n "$TEST_TFVARS" ]; then
          NORMALISED_VARS=$(echo "$TEST_TFVARS" | tr '\n,' ' ' | tr -s ' ')

          read -ra PAIRS <<< "$NORMALISED_VARS"
          for pair in "${PAIRS[@]}"; do
            pair=$(echo "$pair" | xargs)
            if [ -n "$pair" ]; then
              if [[ "$pair" =~ ^[a-zA-Z_][a-zA-Z0-9_]*=.* ]]; then
                TEST_TFVAR_ARGS="$TEST_TFVAR_ARGS -var=$pair"
                echo "Added test tfvar: ${pair%%=*}"
              else
                echo "Error: Invalid test tfvar format: $pair"
                echo "Expected format: key=value"
                exit 1
              fi
            fi
          done

          TEST_TFVAR_ARGS=$(echo "$TEST_TFVAR_ARGS" | sed 's/^ *//')
        fi

        echo "test-tfvar-args=$TEST_TFVAR_ARGS" >> $GITHUB_OUTPUT

    - name: Validate
      id: validate
      if: ${{ steps.parse-steps.outputs.run_validate == 'true' }}
      shell: bash
      working-directory: ${{ inputs.workdir }}
      run: |
        set +e
        FMT_DIFF=$(tofu fmt -check -diff)
        FMT_SUMMARY=$(tofu fmt -check | xargs)
        VALIDATE_JSON=$(tofu validate ${{ steps.parse-tfvar-files.outputs.tfvar-file-args }} ${{ steps.parse-tfvars.outputs.tfvar-args }} -json)
        IS_VALID=$(echo "$VALIDATE_JSON" | jq -r '.valid')
        set -e

        CURRENT_BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF_NAME:-main}}
        SOURCE_REPO="$GITHUB_REPOSITORY"
        SOURCE_REF="$CURRENT_BRANCH"

        if [ "${GITHUB_EVENT_NAME}" = "pull_request" ] && [ -f "$GITHUB_EVENT_PATH" ]; then
          PR_REPO=$(jq -r '.pull_request.head.repo.full_name // empty' "$GITHUB_EVENT_PATH")
          PR_REF=$(jq -r '.pull_request.head.ref // empty' "$GITHUB_EVENT_PATH")
          if [ -n "$PR_REPO" ]; then
            SOURCE_REPO="$PR_REPO"
          fi
          if [ -n "$PR_REF" ]; then
            SOURCE_REF="$PR_REF"
          fi
        fi

        VALIDATION_SUMMARY="| Check | Status | Details |
        |-------|--------|---------|
        "
        VALIDATION_ERRORS=""

        HAS_FAILURES=false

        if [ -z "$FMT_SUMMARY" ]; then
          echo "fmt_failed=false" >> $GITHUB_OUTPUT
          VALIDATION_SUMMARY+="| üéØ Format | ‚úÖ Pass | All files are properly formatted |
          "
        else
          # Output fmt failure flag
          echo "fmt_failed=true" >> $GITHUB_OUTPUT
          HAS_FAILURES=true

          # Output fmt summary
          printf 'fmt_summary=%s\n' "$FMT_SUMMARY" >> "$GITHUB_OUTPUT"

          VALIDATION_SUMMARY+="| üéØ Format | ‚ùå Fail | \`$FMT_SUMMARY\` |
          "
          VALIDATION_ERRORS+="### üéØ Format Issues
          Format validation has failed on the following files: **$FMT_SUMMARY**

          üîß Changes Required:
          \`\`\`diff
          $FMT_DIFF
          \`\`\`

          > [!NOTE]
          > Running \`tofu fmt --recursive\` from your repository will auto fix these formatting issues.
          > Better yet, set this up in your [pre-commit config](https://github.com/tofuutils/pre-commit-opentofu?tab=readme-ov-file#tofu_fmt) to never let formatting issues break a pipeline ever again!

          "
        fi

        if [ "$IS_VALID" = "true" ]; then
          echo "validate_failed=false" >> $GITHUB_OUTPUT
          VALIDATION_SUMMARY+="| üîç Validate | ‚úÖ Pass | Configuration is valid |
          "
        else
          echo "validate_failed=true" >> $GITHUB_OUTPUT
          HAS_FAILURES=true

          # Count different error types
          TOTAL_VALIDATE_ERRORS=$(echo "$VALIDATE_JSON" | jq -r '.error_count // 0')

          # Group errors by summary
          VALIDATE_SUMMARY=$(echo "$VALIDATE_JSON" | jq -r '
            [.diagnostics[] | .summary] |
            group_by(.) |
            map({
              summary: .[0],
              count: length
            }) |
            map(
              if .count == 1 then
                (.count | tostring) + " " + (.summary | ascii_downcase)
              else
                (.count | tostring) + " " + (.summary | ascii_downcase) + "s"
              end
            ) |
            if length == 1 then
              .[0]
            elif length == 2 then
              .[0] + " & " + .[1]
            else
              (.[0:-1] | join(", ")) + " & " + .[-1]
            end
          ')

          # Generate detailed validate output
          VALIDATE_DETAILED=$(echo "$VALIDATE_JSON" | jq -r --arg repo "$SOURCE_REPO" --arg ref "$SOURCE_REF" --arg workdir "${{ inputs.workdir }}" '
            .diagnostics[] |
            "**" + (.severity[0:1] | ascii_upcase) + .severity[1:] + ":** " + .summary + "\n" +
            "**Detail:** " + .detail + "\n" +
            (if .address then "**Resource:** `" + .address + "`\n" else "" end) +
            (
              if (.range? and .range.filename?) then
                "**File:** `" + .range.filename + "` (Line " + ((.range.start.line // 0) | tostring) + ", Column " + ((.range.start.column // 0) | tostring) + ")\n"
              else
                "**File:** `unknown`\n"
              end
            ) +
            (
              if env.GITHUB_SERVER_URL and ($repo | length) > 0 and ($ref | length) > 0 and (.range? and .range.filename?) then
                " üìç [View in file](" +
                env.GITHUB_SERVER_URL + "/" +
                $repo + "/blob/" +
                $ref + "/" +
                $workdir + "/" +
                .range.filename + "#L" +
                ((.range.start.line // 0) | tostring) + "-L" +
                ((.range.end.line // 0) | tostring) + ")\n"
              else "" end
            ) +
            "# \n"
          ')

          VALIDATION_SUMMARY+="| üéØ Validate | ‚ùå Fail | $VALIDATE_SUMMARY |
          "

          # Output validate summary
          echo "validate_summary=$VALIDATE_SUMMARY" >> $GITHUB_OUTPUT

          VALIDATION_ERRORS+="
          ### ‚ö†Ô∏è Syntax / Configuration Issues
          Syntax Validation Failed with **$TOTAL_VALIDATE_ERRORS** errors

          $VALIDATE_DETAILED
          "
        fi

        echo "has_failures=$HAS_FAILURES" >> $GITHUB_OUTPUT

        cat >> $GITHUB_STEP_SUMMARY << VALIDATION_EOF
        ## üß™ Validate

        $VALIDATION_SUMMARY

        $VALIDATION_ERRORS

        VALIDATION_EOF


    - name: Validate Comment
      if: ${{ github.event_name == 'pull_request' && steps.parse-steps.outputs.run_validate == 'true' && inputs['comment-mode'] != 'off' && inputs['comment-mode'] != 'false' }}
      uses: actions/github-script@v6
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          })
          const commentIdentifier = `${{ inputs['comment-identifier'] }}` || 'tf-github-action';
          const commentMarker = `<!-- ${commentIdentifier}:validate -->`;
          const validationComment = comments.find(comment => {
            return comment.body && comment.body.includes(commentMarker)
          }) || comments.find(comment => {
            return comment.user.type === 'Bot' && comment.body.includes('TF Validate Results')
          })
          const hasFailures = ${{ steps.validate.outputs.has_failures }};
          const fmtFailed = ${{ steps.validate.outputs.fmt_failed }};
          const validateFailed = ${{ steps.validate.outputs.validate_failed }};

          let tableRows = [];

          // Add format row
          if (fmtFailed) {
            tableRows.push(`| üéØ Format | ‚ùå Fail | \`${{ steps.validate.outputs.fmt_summary }}\` |`);
          } else {
            tableRows.push(`| üéØ Format | ‚úÖ Pass | All files are properly formatted |`);
          }

          // Add validate row
          if (validateFailed) {
            tableRows.push(`| üîç Validate | ‚ùå Fail | ${{ steps.validate.outputs.validate_summary }} |`);
          } else {
            tableRows.push(`| üîç Validate | ‚úÖ Pass | Configuration is valid |`);
          }

          let validationResults = `${commentMarker}
          ### üß™ TF Validate Results
          | Check | Status | Details |
          |-------|--------|---------|
          ${tableRows.join('\n')}`;

          if (hasFailures) {
            validationResults += `\n\nFailure details can be found in the [Validate Summary](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
          } else {
            validationResults += `\n\nAll checks **passed!** üéâ`;
          }

          if (validationComment) {
            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: validationComment.id,
              body: validationResults
            })
          } else {
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: validationResults
            })
          }

    - name: Check for validation failures
      if: ${{ steps.parse-steps.outputs.run_validate == 'true' }}
      shell: bash
      run: |
        FAILURES=0

        if [[ "${{ steps.validate.outputs.fmt_failed }}" == "true" ]]; then
          echo "::error::Format validation failed"
          FAILURES=$((FAILURES + 1))
        fi

        if [[ "${{ steps.validate.outputs.validate_failed }}" == "true" ]]; then
          echo "::error::Validation checks failed"
          FAILURES=$((FAILURES + 1))
        fi

        if [[ $FAILURES -gt 0 ]]; then
          exit 1
        else
          echo "::notice::All validation checks passed"
        fi

    - name: Test
      id: test
      if: ${{ steps.parse-steps.outputs.run_test == 'true' }}
      shell: bash
      working-directory: ${{ inputs.workdir }}
      run: |
        TEST_DIR="${{ inputs['test-dir'] }}"
        TEST_TFVAR_FILE_ARGS="${{ steps.parse-test-tfvar-files.outputs.test-tfvar-file-args }}"
        TEST_TFVAR_ARGS="${{ steps.parse-test-tfvars.outputs.test-tfvar-args }}"

        if [ -z "$TEST_DIR" ]; then
          echo "::warning::No test directory configured; no OpenTofu tests were executed."
          echo "test_ran=false" >> $GITHUB_OUTPUT
          echo "test_skipped=true" >> $GITHUB_OUTPUT
          echo "test_failed=false" >> $GITHUB_OUTPUT
          echo "test_status=skipped" >> $GITHUB_OUTPUT
          exit 0
        fi

        if [ ! -d "$TEST_DIR" ]; then
          echo "::warning::Test directory '$TEST_DIR' not found; no OpenTofu tests were executed."
          echo "test_ran=false" >> $GITHUB_OUTPUT
          echo "test_skipped=true" >> $GITHUB_OUTPUT
          echo "test_failed=false" >> $GITHUB_OUTPUT
          echo "test_status=skipped" >> $GITHUB_OUTPUT
          exit 0
        fi

        if ! find "$TEST_DIR" -name "*.tftest.hcl" -print -quit | grep -q .; then
          echo "::warning::No OpenTofu test files found in '$TEST_DIR'; no tests were executed."
          echo "test_ran=false" >> $GITHUB_OUTPUT
          echo "test_skipped=true" >> $GITHUB_OUTPUT
          echo "test_failed=false" >> $GITHUB_OUTPUT
          echo "test_status=skipped" >> $GITHUB_OUTPUT
          exit 0
        fi

        set +e
        tofu test -test-directory="$TEST_DIR" $TEST_TFVAR_FILE_ARGS $TEST_TFVAR_ARGS
        TEST_EXIT=$?
        set -e

        if [ "$TEST_EXIT" -eq 0 ]; then
          TEST_STATUS="pass"
          TEST_DETAILS="All OpenTofu tests passed in \`$TEST_DIR\`."
          echo "test_failed=false" >> $GITHUB_OUTPUT
        else
          TEST_STATUS="fail"
          TEST_DETAILS="OpenTofu tests failed in \`$TEST_DIR\`."
          echo "test_failed=true" >> $GITHUB_OUTPUT
        fi

        echo "test_ran=true" >> $GITHUB_OUTPUT
        echo "test_skipped=false" >> $GITHUB_OUTPUT
        echo "test_status=$TEST_STATUS" >> $GITHUB_OUTPUT

        cat << TEST_EOF >> "$GITHUB_STEP_SUMMARY"
        ## üß™ Test

        | Check | Status | Details |
        |-------|--------|---------|
        | üß™ Tests | $(if [ "$TEST_STATUS" = "pass" ]; then echo "‚úÖ Pass"; else echo "‚ùå Fail"; fi) | $TEST_DETAILS |

        TEST_EOF

    - name: Test Comment
      if: ${{ github.event_name == 'pull_request' && steps.parse-steps.outputs.run_test == 'true' && inputs['comment-mode'] != 'off' && inputs['comment-mode'] != 'false' }}
      uses: actions/github-script@v6
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          })
          const commentIdentifier = `${{ inputs['comment-identifier'] }}` || 'tf-github-action';
          const testDir = `${{ inputs['test-dir'] }}` || 'tests';
          const commentMarker = `<!-- ${commentIdentifier}:test:${testDir} -->`;
          const testComment = comments.find(comment => {
            return comment.body && comment.body.includes(commentMarker)
          })

          const testRan = ${{ steps.test.outputs.test_ran }};
          const testSkipped = ${{ steps.test.outputs.test_skipped }};
          const testFailed = ${{ steps.test.outputs.test_failed }};

          let status = '‚ö†Ô∏è Skipped';
          let details = `No OpenTofu tests were executed in \`${testDir}\`.`;

          if (testRan) {
            if (testFailed) {
              status = '‚ùå Fail';
              details = `OpenTofu tests failed in \`${testDir}\`.`;
            } else {
              status = '‚úÖ Pass';
              details = `All OpenTofu tests passed in \`${testDir}\`.`;
            }
          } else if (testSkipped) {
            details = `No OpenTofu tests were executed in \`${testDir}\`.`;
          }

          const testSummary = `${commentMarker}
          ### üß™ TF Test Results (${testDir})
          | Check | Status | Details |
          |-------|--------|---------|
          | üß™ Tests | ${status} | ${details} |`;

          if (testComment) {
            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: testComment.id,
              body: testSummary
            })
          } else {
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: testSummary
            })
          }

    - name: Check for test failures
      if: ${{ steps.parse-steps.outputs.run_test == 'true' }}
      shell: bash
      run: |
        if [[ "${{ steps.test.outputs.test_failed }}" == "true" ]]; then
          echo "::error::OpenTofu tests failed"
          exit 1
        else
          echo "::notice::OpenTofu tests passed or were skipped"
        fi

    - name: Plan
      id: plan
      if: ${{ steps.parse-steps.outputs.run_plan == 'true' }}
      working-directory: ${{ inputs.workdir }}
      env:
        PLAN_NAME: ${{ inputs.env != '' && format('{0}-plan', inputs.env) || 'plan' }}
      shell: bash
      run: |
        PLAN_ARGS="${{ steps.parse-cli-args.outputs.plan_args }}"
        SUMMARY_MODE="${{ inputs['summary-mode'] }}"

        if [ -z "$SUMMARY_MODE" ]; then
          SUMMARY_MODE="full"
        fi

        case "$SUMMARY_MODE" in
          full|redacted|off)
            ;;
          *)
            echo "Error: summary-mode must be full, redacted, or off"
            exit 1
            ;;
        esac

        tofu plan ${{ steps.parse-tfvar-files.outputs.tfvar-file-args }} ${{ steps.parse-tfvars.outputs.tfvar-args }} $PLAN_ARGS -input=false -out $PLAN_NAME.tfplan

        PLAN=""
        if [ "$SUMMARY_MODE" = "full" ]; then
          PLAN=$(tofu show -no-color $PLAN_NAME.tfplan)
        fi
        PLAN_JSON=$(tofu show -json $PLAN_NAME.tfplan)
        gzip -9 $PLAN_NAME.tfplan

        # Extract summary info
        CREATE_COUNT=$(echo "$PLAN_JSON" | jq '[.resource_changes[]? | select(.change.actions[]? == "create")] | length')
        UPDATE_COUNT=$(echo "$PLAN_JSON" | jq '[.resource_changes[]? | select(.change.actions[]? == "update")] | length')
        DESTROY_COUNT=$(echo "$PLAN_JSON" | jq '[.resource_changes[]? | select(.change.actions[]? == "delete")] | length')

        # Determine if any changes are detected in the plan
        if [ "$CREATE_COUNT" -gt 0 ] || [ "$UPDATE_COUNT" -gt 0 ] || [ "$DESTROY_COUNT" -gt 0 ]; then
          CHANGES=true
        else
          CHANGES=false
        fi

        if [ "$SUMMARY_MODE" != "off" ]; then
          cat << PLAN_EOF >> "$GITHUB_STEP_SUMMARY"
        ## üèóÔ∏è Plan

        | Action | Count |
        |--------|-------|
        | ‚ûï Create | $CREATE_COUNT |
        | üîÑ Update | $UPDATE_COUNT |
        | ‚ùå Destroy | $DESTROY_COUNT |

        PLAN_EOF

          if [ "$SUMMARY_MODE" = "full" ]; then
            cat << PLAN_DETAIL_EOF >> "$GITHUB_STEP_SUMMARY"
        \`\`\`hcl
        $PLAN
        \`\`\`
        ---

        PLAN_DETAIL_EOF
          elif [ "$SUMMARY_MODE" = "redacted" ]; then
            cat << PLAN_DETAIL_EOF >> "$GITHUB_STEP_SUMMARY"
        PLAN_DETAIL_EOF
          fi
        fi

        # Output has_changes boolean
        echo "has_changes=$CHANGES" >> $GITHUB_OUTPUT

        # Output counts
        echo "create_count=$CREATE_COUNT" >> $GITHUB_OUTPUT
        echo "update_count=$UPDATE_COUNT" >> $GITHUB_OUTPUT
        echo "destroy_count=$DESTROY_COUNT" >> $GITHUB_OUTPUT

        echo "::notice::$PLAN_NAME.tfplan created"

    - name: PR Plan Comment
      if: ${{ github.event_name == 'pull_request' && steps.parse-steps.outputs.run_plan == 'true' && inputs['comment-mode'] != 'off' && inputs['comment-mode'] != 'false' }}
      uses: actions/github-script@v6
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          })
          const commentIdentifier = `${{ inputs['comment-identifier'] }}` || 'tf-github-action';
          const commentMarker = `<!-- ${commentIdentifier}:plan -->`;
          const planComment = comments.find(comment => {
            return comment.body && comment.body.includes(commentMarker)
          }) || comments.find(comment => {
            return comment.user.type === 'Bot' && comment.body.includes('TF Plan Summary')
          })
          const hasChanges = ${{ steps.plan.outputs.has_changes }};
          const summaryMode = `${{ inputs['summary-mode'] }}` || 'full';

          const summaryTable = `
          | Action | Count |
          |--------|-------|
          | ‚ûï Create | ${{ steps.plan.outputs.create_count }} |
          | üîÑ Update | ${{ steps.plan.outputs.update_count }} |
          | ‚ùå Destroy | ${{ steps.plan.outputs.destroy_count }} |
          `;

          let plan = '';

          if (hasChanges) {
            plan = `${commentMarker}
            ### üèóÔ∏è TF Plan Summary
            ${summaryTable}
            `;
            if (summaryMode === 'full') {
              plan += `\nFull plan can be found in the [Plan Summary](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
            }
          } else {
            plan = `${commentMarker}
            #### üèóÔ∏è TF Plan Summary
            ${summaryTable}

            \`\`\`hcl
            No changes. Your infrastructure matches the configuration.
            \`\`\``;
          }

          if (planComment) {
            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: planComment.id,
              body: plan
            })
          } else {
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: plan
            })
          }

    - name: Upload Plan
      if: ${{ steps.parse-steps.outputs.run_plan == 'true' && inputs['skip-plan-upload'] != 'true' && steps.parse-retention.outputs.retention_days == '' }}
      env:
        PLAN_NAME: ${{ inputs.env != '' && format('{0}-plan', inputs.env) || 'plan' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.PLAN_NAME }}
        path: ${{ inputs.workdir }}/${{ env.PLAN_NAME }}.tfplan.gz

    - name: Upload Plan (retention)
      if: ${{ steps.parse-steps.outputs.run_plan == 'true' && inputs['skip-plan-upload'] != 'true' && steps.parse-retention.outputs.retention_days != '' }}
      env:
        PLAN_NAME: ${{ inputs.env != '' && format('{0}-plan', inputs.env) || 'plan' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.PLAN_NAME }}
        path: ${{ inputs.workdir }}/${{ env.PLAN_NAME }}.tfplan.gz
        retention-days: ${{ steps.parse-retention.outputs.retention_days }}

    - name: Download Plan
      id: download-plan
      if: ${{ steps.parse-steps.outputs.run_apply == 'true' && steps.parse-steps.outputs.run_plan != 'true' }}
      continue-on-error: true
      env:
        PLAN_NAME: ${{ inputs.env != '' && format('{0}-plan', inputs.env) || 'plan' }}
      uses: actions/download-artifact@v4
      with:
        name: ${{ env.PLAN_NAME }}
        path: ${{ inputs.workdir }}

    - name: Ensure plan artifact exists
      if: ${{ steps.parse-steps.outputs.run_apply == 'true' }}
      working-directory: ${{ inputs.workdir }}
      env:
        PLAN_NAME: ${{ inputs.env != '' && format('{0}-plan', inputs.env) || 'plan' }}
      shell: bash
      run: |
        if [ ! -f "$PLAN_NAME.tfplan.gz" ]; then
          echo "::error::Plan artifact $PLAN_NAME.tfplan.gz not found. Run the plan step before apply."
          exit 1
        fi

    - name: Apply
      id: apply
      if: ${{ steps.parse-steps.outputs.run_apply == 'true' }}
      working-directory: ${{ inputs.workdir }}
      env:
        PLAN_NAME: ${{ inputs.env != '' && format('{0}-plan', inputs.env) || 'plan' }}
      shell: bash
      run: |
        APPLY_ARGS="${{ steps.parse-cli-args.outputs.apply_args }}"
        SUMMARY_MODE="${{ inputs['summary-mode'] }}"

        if [ -z "$SUMMARY_MODE" ]; then
          SUMMARY_MODE="full"
        fi

        case "$SUMMARY_MODE" in
          full|redacted|off)
            ;;
          *)
            echo "Error: summary-mode must be full, redacted, or off"
            exit 1
            ;;
        esac

        gunzip "$PLAN_NAME.tfplan.gz"
        tofu apply -input=false -auto-approve -json -concise $APPLY_ARGS "$PLAN_NAME.tfplan" 2>&1 | tee apply_output.json

        ADDED=0
        CHANGED=0
        DESTROYED=0
        IMPORTED=0
        FORGOTTEN=0

        # Get the final change summary if present
        APPLY_SUMMARY=$(jq -r '
          select(.type == "change_summary") |
          "ADDED=\(.changes.add // 0);CHANGED=\(.changes.change // 0);DESTROYED=\(.changes.remove // 0);IMPORTED=\(.changes.import // 0);FORGOTTEN=\(.changes.forget // 0)"
        ' apply_output.json | tail -1)

        if [ -n "$APPLY_SUMMARY" ]; then
          eval "$APPLY_SUMMARY"
        fi

        RESOURCE_CHANGES="Details redacted."
        OUTPUTS="Outputs redacted."

        if [ "$SUMMARY_MODE" = "full" ]; then
          RESOURCE_CHANGES=$(jq -r '
            select(.hook? and .hook.resource?) |
            .hook.action as $action |
            .hook.resource.resource_type + "." + .hook.resource.resource_name as $resource |
            $resource + " (" +
            (if $action == "create" then "created"
            elif $action == "update" then "updated"
            elif $action == "delete" then "destroyed"
            else $action end) + ")"
          ' apply_output.json)

          if [ -z "$RESOURCE_CHANGES" ]; then
            RESOURCE_CHANGES="No changes"
          fi

          # Get any outputs
          OUTPUTS=$(jq -r '
            select(.type == "outputs") |
            if (.outputs | length) > 0 then
              .outputs | to_entries[] | "- **\(.key)**: " +
              (if .value.sensitive == true then
                "<sensitive>"
              elif (.value.value | type) == "string" then
                .value.value
              else
                (.value.value | tostring)
              end)
            else
              "No outputs"
            end
          ' apply_output.json)

          if [ -z "$OUTPUTS" ]; then
            OUTPUTS="No outputs"
          fi
        fi

        if [ "$SUMMARY_MODE" != "off" ]; then
          cat << APPLY_EOF >> "$GITHUB_STEP_SUMMARY"
        ## üöÄ Apply

        ### Summary
        **Resources:** ${ADDED} added, ${CHANGED} changed, ${DESTROYED} destroyed

        $(if [ ${IMPORTED} -gt 0 ]; then echo "**Imported:** ${IMPORTED}"; fi)
        $(if [ ${FORGOTTEN} -gt 0 ]; then echo "**Forgotten:** ${FORGOTTEN}"; fi)

        ### Resource Changes
        ${RESOURCE_CHANGES}

        ### Outputs
        ${OUTPUTS}
        APPLY_EOF
        fi

        echo "added=${ADDED:-0}" >> $GITHUB_OUTPUT
        echo "changed=${CHANGED:-0}" >> $GITHUB_OUTPUT
        echo "destroyed=${DESTROYED:-0}" >> $GITHUB_OUTPUT
        echo "imported=${IMPORTED:-0}" >> $GITHUB_OUTPUT
        echo "forgotten=${FORGOTTEN:-0}" >> $GITHUB_OUTPUT

        # Calculate has_changed (true if any destructive changes occurred)
        if [ ${ADDED:-0} -gt 0 ] || [ ${CHANGED:-0} -gt 0 ] || [ ${DESTROYED:-0} -gt 0 ]; then
          echo "has_changed=true" >> $GITHUB_OUTPUT
        else
          echo "has_changed=false" >> $GITHUB_OUTPUT
        fi

        echo "::notice::$PLAN_NAME.tfplan applied!"

    - name: PR Apply Comment
      if: ${{ github.event_name == 'pull_request' && steps.parse-steps.outputs.run_apply == 'true' && inputs['comment-mode'] != 'off' && inputs['comment-mode'] != 'false' }}
      uses: actions/github-script@v6
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          })
          const commentIdentifier = `${{ inputs['comment-identifier'] }}` || 'tf-github-action';
          const commentMarker = `<!-- ${commentIdentifier}:apply -->`;
          const applyComment = comments.find(comment => {
            return comment.body && comment.body.includes(commentMarker)
          }) || comments.find(comment => {
            return comment.user.type === 'Bot' && comment.body.includes('TF Apply Summary')
          })
          const summaryMode = `${{ inputs['summary-mode'] }}` || 'full';

          const added = ${{ steps.apply.outputs.added }};
          const changed = ${{ steps.apply.outputs.changed }};
          const destroyed = ${{ steps.apply.outputs.destroyed }};
          const imported = ${{ steps.apply.outputs.imported }};
          const forgotten = ${{ steps.apply.outputs.forgotten }};

          let applySummary = `${commentMarker}
          ### üöÄ TF Apply Summary
          **Resources:** ${added} added, ${changed} changed, ${destroyed} destroyed
          ${imported > 0 ? `**Imported:** ${imported}` : ''}
          ${forgotten > 0 ? `**Forgotten:** ${forgotten}` : ''}
          `;
          if (summaryMode === 'full') {
            applySummary += `\nFull apply output can be found in the [Apply Summary](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
          }

          if (applyComment) {
            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: applyComment.id,
              body: applySummary
            })
          } else {
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: applySummary
            })
          }
